import { ChangeDetectionStrategy, Component, ElementRef, Input, OnChanges, OnDestroy, OnInit, SimpleChanges, ViewEncapsulation } from '@angular/core';
import { ALL_SIZES, Size } from '../../types/size';
import { generateSignature, injectStyle, sanitizeCssValue } from '../helpers/atom-config-helper';

/**
 * Switcher component that arranges its children in a responsive layout.
 * It switches from a multi-column layout to a single-column layout based on the specified threshold and limit.
 * It uses flexbox to create a flexible and responsive design.
 * 
 * The style is dynamically generated and injected based on the component's configuration.
 * To avoid style conflicts, each unique configuration generates a unique signature used in the CSS class and data attribute.
 * This ensures that multiple instances of the Switcher component with different configurations can coexist without style interference.
 * But also allows style reuse when multiple instances share the same configuration.
 * 
 * To optimize performance, the component only updates the injected style when relevant input properties change.
 * This minimizes unnecessary style recalculations and injections.
 * 
 * The component template is only a ng-content wrapper since all the layout is handled via CSS, and the class is added 
 * on the native element generated by angular (which has the tag pc-switcher).
 */

@Component({
  selector: 'pc-switcher',
  imports: [],
  template: `<ng-content></ng-content>`,
  encapsulation: ViewEncapsulation.None,
  changeDetection: ChangeDetectionStrategy.OnPush,
  host: { 'data-pc-component': 'switcher' }
})
export class Switcher implements OnInit, OnChanges, OnDestroy {

  @Input() threshold: Size | string = 's2';
  @Input() gap: Size = 's1';
  @Input() limit: number = 4;
  ident?: string;
  config: { threshold: string; gap: string; limit: number; } | null = null;

  constructor(private element: ElementRef) {
  }
  ngOnDestroy(): void {
    try {
      const host = this.element.nativeElement as HTMLElement;
      host.removeAttribute('data-pc-switcher');
      host.classList.remove('switcher');
    } catch (_e) {
      console.warn('Could not clean up Switcher attributes on destroy');
    }
  }

  ngOnInit(): void {
    this.updateConfigAndSignature();
    this.updateStyle();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (!this.ident) return;
    // If any input that affects layout changed, refresh the injected style
    if (changes['threshold'] || changes['gap'] || changes['limit']) {
      this.updateConfigAndSignature();
      this.updateStyle();
    }
  }

  updateConfigAndSignature() {
    const threshold = ALL_SIZES.includes(this.threshold as Size) ? `var(--${this.threshold})` : sanitizeCssValue(this.threshold);
    const gap = ALL_SIZES.includes(this.gap as Size) ? `var(--${this.gap})` : sanitizeCssValue(this.gap);
    const limit = Math.max(1, Math.floor(Number(this.limit) || 1));
    this.config = {
      threshold,
      gap,
      limit
    };
    const signature = `pc-switcher-${generateSignature(this.config)}`
    this.ident = signature;
  }

  private generateStyle(signature: string, config: { gap: string; threshold: string; limit: number }): string {
    const { gap, threshold, limit } = config;
    return `
    .switcher[data-pc-switcher="${signature}"]{
      display: flex;
      flex-wrap: wrap;
      gap: ${gap};
    }

    .switcher[data-pc-switcher="${signature}"] > * {
        flex-grow: 1;
        flex-basis: calc((${threshold} - 100%) * 999);
    }

    .switcher[data-pc-switcher="${signature}"] > :nth-child(n+${limit+1}),
    .switcher[data-pc-switcher="${signature}"] > :nth-child(n+${limit+1}) ~ * {
        flex-basis: 100%;
    }
  `;
  }

  private updateStyle(): void {
    if (!this.config || !this.ident) return;
    const style = this.generateStyle(this.ident, this.config);
    injectStyle("pc-switcher",this.ident, style);
    const host = this.element.nativeElement as HTMLElement;
    host.classList.add('switcher');
    host.setAttribute('data-pc-switcher', this.ident);
  }
}
